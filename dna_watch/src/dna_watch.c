/*

The original source images are from:

https://openclipart.org/detail/95197/genetic-code-bw-by-j_alves
https://openclipart.org/detail/1941/dna-helix-by-hs

The source image was then modified in Photoshop.

*/

#include "pebble_os.h"
#include "pebble_app.h"
#include "pebble_fonts.h"


// uuid generated by create_pebble_project.py script used to create watch project
#define MY_UUID { 0x83, 0x9D, 0x48, 0xBE, 0xE1, 0xA5, 0x4E, 0x8A, 0xB1, 0x1E, 0x32, 0xB2, 0xE3, 0x19, 0xA3, 0xD4 }
PBL_APP_INFO(MY_UUID,
             "DNA", "Lightwriter Visions",
             1, 0, /* App version */
             RESOURCE_ID_IMAGE_MENU_ICON,
             APP_INFO_WATCH_FACE);


Window window;
BmpContainer background_image_container;
// Using this is a workaround as there's currently no other way to
// allocate storage for a bitmap--but the extra automatically created
// layer is useful for getting dimension information anyway.
RotBmpContainer minute_image_container;
RotBmpContainer hour_image_container;

int32_t current_minute_layer_angle = 0;
int32_t current_hour_layer_angle = 0;
GPoint minute_layer_ic = {0,0};
GPoint hour_layer_ic = {0,0};

#define SECONDS true

//Layer center_display_layer;
Layer second_display_layer;



/* -------------- TODO: Remove this and use Public API ! ------------------- */

// from src/core/util/misc.h

#define MAX(a,b) (((a)>(b))?(a):(b))

// From src/fw/ui/rotate_bitmap_layer.c

//! newton's method for floor(sqrt(x)) -> should always converge
static int32_t integer_sqrt(int32_t x) {
  if (x < 0) {
    ////    PBL_LOG(LOG_LEVEL_ERROR, "Looking for sqrt of negative number");
    return 0;
  }

  int32_t last_res = 0;
  int32_t res = (x + 1)/2;
  while (last_res != res) {
    last_res = res;
    res = (last_res + x / last_res) / 2;
  }
  return res;
}

void rot_bitmap_set_src_ic(RotBitmapLayer *image, GPoint ic) {
  image->src_ic = ic;

  // adjust the frame so the whole image will still be visible
  const int32_t horiz = MAX(ic.x, abs(image->bitmap->bounds.size.w - ic.x));
  const int32_t vert = MAX(ic.y, abs(image->bitmap->bounds.size.h - ic.y));

  GRect r = layer_get_frame(&image->layer);
  //// const int32_t new_dist = integer_sqrt(horiz*horiz + vert*vert) * 2;
  const int32_t new_dist = (integer_sqrt(horiz*horiz + vert*vert) * 2) + 1; //// Fudge to deal with non-even dimensions--to ensure right-most and bottom-most edges aren't cut off.

  r.size.w = new_dist;
  r.size.h = new_dist;
  layer_set_frame(&image->layer, r);

  r.origin = GPoint(0, 0);
  ////layer_set_bounds(&image->layer, r);
  image->layer.bounds = r;

  image->dest_ic = GPoint(new_dist / 2, new_dist / 2);

  layer_mark_dirty(&(image->layer));
}

/* ------------------------------------------------------------------------- */


void set_hand_angle(RotBmpContainer *hand_image_cont, unsigned int hand_angle) {

  signed short x_fudge = 0;
  signed short y_fudge = 0;

  hand_image_cont->layer.rotation =  TRIG_MAX_ANGLE * hand_angle / 360;

  //
  // Due to rounding/centre of rotation point/other issues of fitting
  // square pixels into round holes by the time hands get to 6 and 9
  // o'clock there's off-by-one pixel errors.
  //
  // The `x_fudge` and `y_fudge` values enable us to ensure the hands
  // look centred on the minute marks at those points. (This could
  // probably be improved for intermediate marks also but they're not
  // as noticable.)
  //
  // I think ideally we'd only ever calculate the rotation between
  // 0-90 degrees and then rotate again by 90 or 180 degrees to
  // eliminate the error.
  //
  if (hand_angle >= 180) {
    x_fudge = -1;
  }
  if ( (hand_angle > 225) && (hand_angle < 315) ) {
    x_fudge = -2;
  }
  x_fudge++;

  // (144 = screen width, 168 = screen height)
  hand_image_cont->layer.layer.frame.origin.x = (144/2) - (hand_image_cont->layer.layer.frame.size.w/2) + x_fudge;
  hand_image_cont->layer.layer.frame.origin.y = (168/2) - (hand_image_cont->layer.layer.frame.size.h/2) + y_fudge;

  layer_mark_dirty(&hand_image_cont->layer.layer);
}

#ifdef FOO
void update_hand_positions() {

  PblTm t;
  get_time(&t);
  // unsigned int hand_angle_precalc = ((t.tm_hour % 12) * 30) + (t.tm_min/2);

  unsigned int minute_angle = (TRIG_MAX_ANGLE / 360) * (t.tm_min * 6 + t.tm_sec / 10);

  unsigned int hour_angle = (TRIG_MAX_ANGLE / 360) * ((t.tm_hour % 12) * 30 + t.tm_min / 2);
  
  // sets angle, marks layer dirty
    set_hand_angle(&hour_image_container, hour_angle);
    set_hand_angle(&minute_image_container, minute_angle);
}
#endif

void update_hand_positions() {

  PblTm t;

  get_time(&t);

  set_hand_angle(&hour_image_container, ((t.tm_hour % 12) * 30) + (t.tm_min/2)); // ((((t.tm_hour % 12) * 6) + (t.tm_min / 10))) / (12 * 6));

  set_hand_angle(&minute_image_container, t.tm_min * 6);
#if SECONDS
  //set_hand_angle(&second_hand_image_container, t.tm_sec * 6);
  layer_mark_dirty(&second_display_layer);
#endif
}

/* -------------- TODO: Remove this and use Public API ! ------------------- */
#if SECONDS
void second_display_layer_update_callback(Layer *me, GContext* ctx) {
  (void)me;

  PblTm t;
  get_time(&t);

  int32_t second_angle = t.tm_sec * (0xffff/60);
  int second_hand_length = 70;

//  graphics_context_set_fill_color(ctx, GColorBlack);
  graphics_context_set_stroke_color(ctx, GColorBlack);
// graphics_context_set_text_color(GContext *ctx, GColor color);
// graphics_context_set_compositing_mode(GContext *ctx, GCompOp mode);

  GPoint center = grect_center_point(&me->frame);
  GPoint second = GPoint(center.x + second_hand_length * sin_lookup(second_angle)/0xffff,
center.y + (-second_hand_length) * cos_lookup(second_angle)/0xffff);

  graphics_draw_line(ctx, center, second);
}
#endif

#ifdef OLD_CALLBACKS
void minute_display_layer_update_callback(Layer *me, GContext* ctx) {
  (void)me;

  PblTm t;

  get_time(&t);

#ifdef FOO
  unsigned int angle = t.tm_min * 6 + t.tm_sec / 10;
  current_minute_layer_angle = (TRIG_MAX_ANGLE / 360) * angle;
  // This will automatically mark the layer dirty and update it.
  rotbmp_pair_layer_set_angle(&minute_image_container.layer, current_minute_layer_angle);
#endif
  update_hand_positions(); 
}

void hour_display_layer_update_callback(Layer *me, GContext* ctx) {
  (void)me;

  PblTm t;

  get_time(&t);
#ifdef FOO
  unsigned int angle = (t.tm_hour % 12) * 30 + t.tm_min / 2;
  current_hour_layer_angle = (TRIG_MAX_ANGLE / 360) * angle;

  // This will automatically mark the layer dirty and update it.
  rotbmp_pair_layer_set_angle(&hour_image_container.layer, current_hour_layer_angle);
#endif
  update_hand_positions(); 
}
#endif

void handle_init(AppContextRef ctx) {
  (void)ctx;

  window_init(&window, "DNA Watch");
  // set window-layer BG to black to save on background PNG bits/size
  window_set_background_color(&window, GColorBlack);
  window_stack_push(&window, true /* Animated */);
  resource_init_current_app(&APP_RESOURCES);

  bmp_init_container(RESOURCE_ID_IMAGE_BACKGROUND, &background_image_container);
  layer_add_child(&window.layer, &background_image_container.layer.layer);


  rotbmp_init_container(RESOURCE_ID_IMAGE_HOUR, &hour_image_container);
  //layer_init(&hour_image_container.layer.layer, window.layer.frame);
  //layer_set_bounds(&hour_image_container.layer.layer, window.layer.frame);
  hour_image_container.layer.compositing_mode = GCompOpClear;
  rot_bitmap_set_src_ic(&hour_image_container.layer, GPoint(6, 51));
  layer_add_child(&window.layer, &hour_image_container.layer.layer);

  rotbmp_init_container(RESOURCE_ID_IMAGE_MINUTE, &minute_image_container);
  //layer_init(&minute_image_container.layer.layer, window.layer.frame);
  //layer_set_bounds(&minute_image_container.layer.layer, window.layer.frame);
  minute_image_container.layer.compositing_mode = GCompOpClear;
  rot_bitmap_set_src_ic(&minute_image_container.layer, GPoint(6, 66));
  layer_add_child(&window.layer, &minute_image_container.layer.layer);
  
  //GCompOpAssign, GCompOpAssignInverted, GCompOpOr, GCompOpAnd, GCompOpClear

  //hour_image_container.layer.layer.update_proc = &hour_display_layer_update_callback;
  //minute_image_container.layer.layer.update_proc = &minute_display_layer_update_callback;

  update_hand_positions(); 
#if SECONDS
  layer_init(&second_display_layer, window.layer.frame);
  second_display_layer.update_proc = &second_display_layer_update_callback;
  layer_add_child(&window.layer, &second_display_layer);
#endif
}

void handle_deinit(AppContextRef ctx) {
  (void)ctx;

  bmp_deinit_container(&background_image_container);

  rotbmp_deinit_container(&hour_image_container);
  rotbmp_deinit_container(&minute_image_container);

  //fonts_unload_custom_font(date_font);
}

void handle_tick(AppContextRef ctx, PebbleTickEvent *t){
  (void)t;
  (void)ctx;

  update_hand_positions();
#if SECONDS
  layer_mark_dirty(&second_display_layer);
#endif
}


void pbl_main(void *params) {
  PebbleAppHandlers handlers = {
    .init_handler = &handle_init,
    .deinit_handler = &handle_deinit,
    .tick_info = {
      .tick_handler = &handle_tick,
#if SECONDS
      .tick_units = SECOND_UNIT
#else
      .tick_units = MINUTE_UNIT
#endif
      }
  };
  app_event_loop(params, &handlers);
}